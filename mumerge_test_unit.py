import numpy as np
from math import log10, floor
from itertools import groupby
from collections import defaultdict
import matplotlib.cm
import matplotlib.pyplot as plt

###############################################################################
def mu_generator(npl = (10000, 0.5, 100), rep=2,cond=1,N=100):
    '''
    '''
    #n_sites = int(rep * cond * N)
    n, p, l = npl
    print("mu +/- stdev: 0 +/-", np.sqrt(n*p*(1-p)))
    print("width mean (and variance):", l) 
    mu_dict = defaultdict(dict)
    
    order = floor(log10(N))

    # Initialize dictionary in same format as that generated by tfit_dict()
    for i in range(N):
        sites = []
        for r in range(rep):
            for c in range(cond):
                mu = np.random.binomial(n, p) - int(n/2)
                sig = np.random.poisson(l)
                sampid = '_'.join([str(c), str(r)])
                sites.append((mu-sig, mu+sig, 0, sampid))
        
        start, stop, cov, ids = zip(*sites)
        region = (int(min(start)), int(max(stop)))

        zi = str(i).zfill(order+1)
        mu_dict[''.join(['T', zi])] = {region: sites}
    
    return dict(mu_dict)

###############################################################################
def test_groupings(mu_dict):
    '''
    '''
    sampid = set()
    for region in mu_dict.values():
        for sites in region.values():
            tmp = set([m[3] for m in sites])
            sampid = sampid.union(tmp)
    
    sampid = sorted(list(sampid))

    groups = groupby(sampid, key = lambda s: s.split('_')[0])
    groups = [sorted(list(g)) for k, g in groups]

    return sorted(groups)
###############################################################################
def list2tups(int_list):

    tup_list = []
    diffs = [(i-e, e) for i, e in enumerate(int_list)]

    index, ints = zip(*diffs)

    for i in set(index):
        group = [e[1] for e in diffs if e[0] == i]
        tup_list.append((min(group), max(group)))

    return sorted(tup_list)

###############################################################################
def tup_union(sites):
    
    union = []
    for site in sites:
        union.extend(list(range(site[0], site[1]+1)))

    union = sorted(list(set(union)))

    if union != []:
        final_tups = list2tups(union)
    else:
        return [(0, 0, 0, 'union')]

    starts, stops = list(zip(*final_tups))
    covs = [0 for i in range(len(final_tups))]
    ids = ['union' for i in range(len(final_tups))]

    final_tups = list(zip(starts, stops, covs, ids))

    return final_tups


###############################################################################
def tup_intersect(sites):

    intersect = [list(range(s[0], s[1]+1)) for s in sites]
    intersect = set(intersect[0]).intersection(*intersect[1:])
    intersect = sorted(list(intersect))
    
    if intersect != []:
        final_tups = list2tups(intersect)
    else:
        return [(0, 0, 0, 'intersect')]

    starts, stops = list(zip(*final_tups))
    covs = [0 for i in range(len(final_tups))]
    ids = ['intersect' for i in range(len(final_tups))]

    final_tups = list(zip(starts, stops, covs, ids))

    return final_tups

###############################################################################
def line_maker(sites, union=True, intersect=True):
    
    starts, stops, cov, sampids = zip(*sites)
    num = len(sites)
    #print(sampids)

    cmap = matplotlib.cm.get_cmap('tab10')
    index = {sampid: i for i, sampid in enumerate(sorted(sampids))}
    xmin = min(starts)
    xmax = max(stops)
    #print(index)
    
    for site in sites:
        idx = index[site[3]]

        cidx = int(site[3][0])
        line = plt.Line2D((site[0] ,site[1]), (idx+1, idx+1), 
                            lw=4.5, color=cmap(cidx))

        plt.gca().add_line(line)
        plt.scatter((site[0]+site[1])/2, idx+1, color=cmap(cidx))
    
    plt.xlim([xmin-1, xmax+1])
    plt.ylim([0, num+1])

    if union == True:
        union_tup = tup_union(sites)
        pos = 0.3
        for un in union_tup:
            line = plt.Line2D((un[0] ,un[1]), (pos, pos), lw=4.5, color='k')
            plt.gca().add_line(line)
            plt.scatter((un[0]+un[1])/2, pos, color='k')
        plt.ylim([-1, num+1])

    if intersect == True:
        inter_tup = tup_intersect(sites)
        pos = -0.3
        for it in inter_tup:
            line = plt.Line2D((it[0] ,it[1]), (pos, pos), lw=4.5, color='k')
            plt.gca().add_line(line)
            plt.scatter((it[0]+it[1])/2, pos, color='k')
        plt.ylim([-1, num+1])

    plt.show()


